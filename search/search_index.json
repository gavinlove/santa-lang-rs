{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>CLI - WebAssembly - Lambda - PHP Extension</p>"},{"location":"#santa-lang","title":"santa-lang","text":"<p>An functional, C-like programming language for solving Advent of Code puzzles.</p> <p>Influenced by: Rust, Python, Clojure, F#, Scala</p>"},{"location":"#why","title":"Why?","text":"<p>Over the past several years I have been slowly working through the previous Advent of Code calendars. For each calendar I opt to solve the puzzles in a new programming language, to familiarise myself with other ways of understanding and working. However, there comes a time in each calendar that I grow to dislike some aspect of the language. So I had an idea... why not give this whole programming langauge design a go. That way if I grow to dislike this language, I only have myself to blame!</p> <p>Welcome santa-lang, my tree-walking interpreted programming language designed to help tackle Advent of Code puzzles.</p>"},{"location":"builtins/","title":"Builtin Functions","text":"<p>The language trys to follow Python's batteries included motto, where-by all desired functionality is included out of the box. This is achieved by the inclusion of many different builtin functions, allowing you tackle many general-purpose and Advent of Code specific problems. The following builtin functions are available in all runtimes:</p>"},{"location":"builtins/#collection","title":"Collection","text":""},{"location":"builtins/#list","title":"list","text":"<pre><code>list(value)</code></pre> <p>Return the List representation of the given value.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>list([1, 2, 3])</code></pre> <pre><code>list({1, 2, 3})</code></pre> <p>Ouput is a List of List tuples <code>[key, value]</code>.</p> <pre><code>list(#{1: 2, 3: 4})</code></pre> <pre><code>list(\"ab\")</code></pre> <pre><code>list(1..5)</code></pre> <pre><code>list(1..=5)</code></pre>"},{"location":"builtins/#set","title":"set","text":"<pre><code>set(value)</code></pre> <p>Return the Set representation of the given value.</p> ListSetStringExclusive RangeInclusive Range <pre><code>set([1, 2, 3])</code></pre> <pre><code>set({1, 2, 3})</code></pre> <pre><code>set(\"ab\")</code></pre> <pre><code>set(1..5)</code></pre> <pre><code>set(1..=5)</code></pre>"},{"location":"builtins/#dict","title":"dict","text":"<pre><code>dict(value)</code></pre> <p>Return the Dictionary representation of the given value.</p> ListDictionary <p>Input is a List of List tuples <code>[key, value]</code>.</p> <pre><code>dict([[1, 2], [3, 4]])</code></pre> <pre><code>dict(#{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#get","title":"get","text":"<pre><code>get(index, collection)</code></pre> <p>Get an element within a collection, following the rules laid out in Indexing. If an element can not be found at that index then <code>nil</code> is returned.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded Range <pre><code>get(1, [1, 2])</code></pre> <pre><code>get(1, {1, 2})</code></pre> <pre><code>get(1, #{1: 2, 3: 4})</code></pre> <pre><code>get(1, \"ab\")</code></pre> <pre><code>get(1, 1..5)</code></pre> <pre><code>get(1, 1..=5)</code></pre> <pre><code>get(1, 0..)</code></pre>"},{"location":"builtins/#size","title":"size","text":"<pre><code>size(collection)</code></pre> <p>Get the size of a collection.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>size([1, 2])</code></pre> <pre><code>size({1, 2})</code></pre> <pre><code>size(#{1: 2, 3: 4})</code></pre> <pre><code>size(\"ab\")</code></pre> <pre><code>size(1..5)</code></pre> <pre><code>size(1..=5)</code></pre>"},{"location":"builtins/#push","title":"push","text":"<pre><code>push(value, collection)</code></pre> <p>Add a new value to a collection.</p> ListSet <p>The value is appended to the end of the List.</p> <pre><code>push(3, [1, 2])</code></pre> <pre><code>push(3, {1, 2})</code></pre>"},{"location":"builtins/#assoc","title":"assoc","text":"<pre><code>assoc(key, value, collection)</code></pre> <p>Associate the provided key/index with the given value in a collection.</p> ListDictionary <pre><code>assoc(0, 3, [1, 2])</code></pre> <p>If the index is not already present <code>nil</code> values are inserted up to the given index.</p> <pre><code>assoc(1, 1, [])</code></pre> <pre><code>assoc(1, 1, #{1: 2, 3: 4})</code></pre> <pre><code>assoc(0, 1, #{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#update","title":"update","text":"<pre><code>update(key, updater, collection)</code></pre> <p>Update the given index/key of a collection using the supplied pure <code>updater</code> function. The <code>updater</code> function is supplied the current value at the given index/key, if not present <code>nil</code> is supplied.</p> ListDictionary <pre><code>update(0, _ + 1, [1, 2])</code></pre> <p>If the index is not already present <code>nil</code> values are inserted up to the given index.</p> <pre><code>update(1, || 1, [])</code></pre> <pre><code>update(0, || 1, #{})</code></pre> <pre><code>update(1, _ + 1, #{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#update_d","title":"update_d","text":"<pre><code>update_d(key, default, updater, collection)</code></pre> <p>Update the given index/key of a collection using the supplied pure <code>updater</code> function. The <code>updater</code> function is supplied the current value at the given index/key, if not present the default value is supplied.</p> ListDictionary <pre><code>update_d(0, 0, _ + 1, [1, 2])</code></pre> <p>If the index is not already present <code>nil</code> values are inserted up to the given index.</p> <pre><code>update_d(1, 0, _ + 1, [])</code></pre> <pre><code>update_d(0, 0, _ + 1, #{})</code></pre> <pre><code>update_d(1, 0, _ + 1, #{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#map","title":"map","text":"<pre><code>map(mapper, collection)</code></pre> <p>Return a collection with a pure <code>mapper</code> function applied over each element within the given collection.</p> ListSetDictionaryString <pre><code>map(_ + 1, [1, 2])</code></pre> <pre><code>map(_ + 1, {1, 2})</code></pre> <pre><code>map(_ + 1, #{1: 2, 3: 4})</code></pre> <p>The <code>mapper</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>map(|v, k| \"\" + k + \": \" + v, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the mapping. The returned collection is a List.</p> <pre><code>map(_ * 2, \"ab\")</code></pre> <p>Lazy Sequences return another Lazy Sequence, which when resolved will lazily apply the required mapping.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>map(_ + 1, 1..5) |&gt; list</code></pre> <pre><code>map(_ + 1, 1..=5) |&gt; list</code></pre> <pre><code>map(_ + 1, 0..) |&gt; take(3)</code></pre> <pre><code>map(_ + 1, repeat(1)) |&gt; take(3)</code></pre>"},{"location":"builtins/#filter","title":"filter","text":"<pre><code>filter(predicate, collection)</code></pre> <p>Return a collection based on a pure <code>predicate</code> function holding truthy for the given element in a collection.</p> ListSetDictionaryString <pre><code>filter(_ == 1, [1, 2])</code></pre> <pre><code>filter(_ == 1, {1, 2})</code></pre> <pre><code>filter(_ == 2, #{1: 2, 3: 4})</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>map(|_, k| k == 3, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the predicate. The returned collection is a List.</p> <pre><code>filter(_ == \"a\", \"ab\")</code></pre> <p>Lazy Sequences return another Lazy Sequence, which when resolved will lazily apply the required filter.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>filter(_ % 2, 1..5) |&gt; list</code></pre> <pre><code>filter(_ % 2, 1..=5) |&gt; list</code></pre> <pre><code>filter(_ % 2, 0..) |&gt; take(3)</code></pre> <pre><code>filter(_ != 2, cycle([1, 2, 3])) |&gt; take(3)</code></pre>"},{"location":"builtins/#each","title":"each","text":"<pre><code>each(side_effect, collection)</code></pre> <p>Apply a side-effecting function over each element in the given collection.</p> ListSetDictionaryString <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, [1, 2]);\nacc;</code></pre> <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, {1, 2});\nacc;</code></pre> <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, #{1: 2, 3: 4});\nacc;</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>let mut acc = 0;\neach(|_, k| acc = ac + k, #{1: 2, 3: 4});\nacc;</code></pre> <p>Each character is considered an element within the iteration. The returned collection is a List.</p> <pre><code>let mut acc = 0;\neach(|_| acc = acc + 1, \"ab\");\nacc;</code></pre> <p>The function can <code>break</code> which will terminate the collection iteration early.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, 1..5);\nacc;</code></pre> <pre><code>let mut acc = 0;\neach(|v| acc = acc + v, 1..=5);\nacc;</code></pre> <pre><code>let mut acc = 0;\n0.. |&gt; each |v| {\n  if v == 10 { break nil } else { acc = acc + v }\n};\nacc;</code></pre> <pre><code>let mut acc = 0;\niterate(_ + 1, 1) |&gt; each |v| {\n  if v == 10 { break nil } else { acc = acc + v }\n};\nacc;</code></pre>"},{"location":"builtins/#reduce","title":"reduce","text":"<pre><code>reduce(reducer, collection)</code></pre> <p>Apply a pure <code>reducer</code> function over a given collection. The initial accumulator value supplied upon first iteration is the first element in the collection. If the collection is empty then an error is thrown.</p> ListSetDictionaryString <pre><code>reduce(+, [1, 2])</code></pre> <pre><code>reduce(+, {1, 2})</code></pre> <pre><code>reduce(+, #{1: 2, 3: 4})</code></pre> <p>The <code>reducer</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>reduce(|acc, _, k| acc + k, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the reduction. The returned collection is a List.</p> <pre><code>reduce(|acc, ch| ch + acc, \"ab\")</code></pre> <p>The function can <code>break</code> which will terminate the collection iteration early.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>reduce(+, 1..5)</code></pre> <pre><code>reduce(+, 1..=5)</code></pre> <pre><code>0.. |&gt; reduce |acc, v| {\n  if acc == 10 { break acc } else { acc + v }\n}</code></pre> <pre><code>iterate(_ + 1, 1) |&gt; reduce |acc, v| {\n  if acc == 10 { break acc } else { acc + v }\n}</code></pre>"},{"location":"builtins/#fold","title":"fold","text":"<pre><code>fold(initial, folder, collection)</code></pre> <p>Apply a pure <code>folder</code> function over a given collection. The initial fold receives the first element and the initial value supplied. If the collection is empty then the initial value is returned.</p> ListSetDictionaryString <pre><code>fold(0, +, [1, 2])</code></pre> <pre><code>fold(0, +, {1, 2})</code></pre> <pre><code>fold(0, +, #{1: 2, 3: 4})</code></pre> <p>The <code>folder</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>fold(0, |acc, _, k| acc + k, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the fold. The returned collection is a List.</p> <pre><code>fold(0, _ + 1, \"ab\")</code></pre> <p>The function can <code>break</code> which will terminate the collection iteration early.</p> Exclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>fold(0, +, 1..5)</code></pre> <pre><code>fold(0, +, 1..=5)</code></pre> <pre><code>0.. |&gt; fold |acc, v| {\n  if acc == 10 { break acc } else { acc + v }\n}</code></pre> <pre><code>iterate(_ + 1, 1) |&gt; fold |acc, v| {\n  if acc == 10 { break acc } else { acc + v }\n}</code></pre>"},{"location":"builtins/#fold_s","title":"fold_s","text":"<pre><code>fold_s(initial, folder, collection)</code></pre> <p>Apply a pure <code>folder</code> function over a given collection, with optional state which is passed along throughout the fold. The accumulated value is a List comprising of the first element being the resulting folded value, and other elements being state you wish to pass on to the next iteration. Upon completion, the extra state is discarded and the folded value is returned. If the collection is empty then the initial value is returned.</p> <pre><code>50..100 |&gt; fold_s(\n  |[acc, x, y], val| [acc + x * y * val, val, val / 2],\n  [0, 0, 0]\n)</code></pre>"},{"location":"builtins/#find","title":"find","text":"<pre><code>find(predicate, collection)</code></pre> <p>Apply a pure <code>predicate</code> function over a given collection, returning the first element where the predicate holds truthy.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>find(_ % 2, [1, 2])</code></pre> <pre><code>find(_ % 2, {1, 2})</code></pre> <pre><code>find(_ % 2, #{1: 2, 3: 4})</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>find(|_, k| k % 2, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the predicate. The returned collection is a List.</p> <pre><code>find(_ == \"b\", \"ab\")</code></pre> <pre><code>find(_ % 2, 1..5)</code></pre> <pre><code>find(_ % 2, 1..=5)</code></pre> <pre><code>find(_ % 2, 0..)</code></pre> <pre><code>find(_ % 2, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#scan","title":"scan","text":"<pre><code>scan(initial, folder, collection)</code></pre> <p>Return a collection which includes the result of each iteration of folding a pure <code>folder</code> function over each element within the given collection.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>scan(0, +, [1, 2])</code></pre> <pre><code>scan(0, +, {1, 2})</code></pre> <pre><code>scan(0, +, #{1: 2, 3: 4})</code></pre> <p>The <code>folder</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>scan(0, |acc, _, k| acc + k, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the fold. The returned collection is a List.</p> <pre><code>scan(\"\", +, \"ab\")</code></pre> <pre><code>scan(0, +, 1..5)</code></pre> <pre><code>scan(0, +, 1..=5)</code></pre>"},{"location":"builtins/#flat_map","title":"flat_map","text":"<pre><code>flat_map(mapper, collection)</code></pre> <p>Apply a pure <code>mapper</code> function over a given collection with the resulting mapped List results being flattened into a single List.</p> <pre><code>flat_map(_ * 2, [[1, 2], [3, 4]])</code></pre>"},{"location":"builtins/#filter_map","title":"filter_map","text":"<pre><code>filter_map(mapper, collection)</code></pre> <p>Apply a pure <code>mapper</code> function over a given collection and filter out the mapped values based on them being truthy. This is a convenience function (inspired by Rust) for the common place <code>map(..) |&gt; filter(..)</code> pattern.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>[1, 2] |&gt; filter_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>{1, 2} |&gt; filter_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>#{1: 2, 3: 4} |&gt; filter_map(|v| if v != 2 { v + 1 })</code></pre> <p>The <code>mapper</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>#{1: 2, 3: 4} |&gt; filter_map(|_, k| if k != 1 { k + 1 })</code></pre> <p>Each character is considered an element within the mapping. The returned collection is a List.</p> <pre><code>\"ab\" |&gt; filter_map(|v| if v != \"a\" { v * 2 })</code></pre> <pre><code>1..5 |&gt; filter_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>1..=5 |&gt; filter_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>1..\n  |&gt; filter_map(|v| if v != 1 { v + 1 })\n  |&gt; take(3)</code></pre> <pre><code>iterate(_ + 1, 1)\n  |&gt; filter_map(|v| if v != 1 { v + 1 })\n  |&gt; take(3)</code></pre>"},{"location":"builtins/#find_map","title":"find_map","text":"<pre><code>find_map(mapper, collection)</code></pre> <p>Apply a pure <code>mapper</code> function over a given collection and find the first mapped element where the value returned is truthy. This is a convenience function (inspired by Rust) for the common place <code>map(..) |&gt; find(..)</code> pattern.</p> ListSetDictionaryStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>[1, 2] |&gt; find_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>{1, 2} |&gt; find_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>#{1: 2, 3: 4} |&gt; find_map(|v| if v != 2 { v + 1 })</code></pre> <p>The <code>mapper</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>#{1: 2, 3: 4} |&gt; find_map(|_, k| if k != 1 { k + 1 })</code></pre> <p>Each character is considered an element within the mapping. The returned collection is a List.</p> <pre><code>\"ab\" |&gt; find_map(|v| if v != \"a\" { v * 2 })</code></pre> <pre><code>1..5 |&gt; find_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>1..=5 |&gt; find_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>1.. |&gt; find_map(|v| if v != 1 { v + 1 })</code></pre> <pre><code>iterate(_ + 1, 1)\n  |&gt; find_map(|v| if v != 1 { v + 1 })</code></pre>"},{"location":"builtins/#count","title":"count","text":"<pre><code>count(predicate, collection)</code></pre> <p>Count the total number of elements where the pure <code>predicate</code> function holds truthy.</p> ListSetDictionaryStringExclusive RangeInclusive Range <pre><code>count(_ % 2, [1, 2, 3, 4])</code></pre> <pre><code>count(_ % 2, {1, 2, 3, 4})</code></pre> <pre><code>count(_ % 2, #{1: 2, 3: 4})</code></pre> <p>The <code>predicate</code> function is suppled both the value and key in the context of a Dictionary.</p> <pre><code>count(|_, k| k % 2, #{1: 2, 3: 4})</code></pre> <p>Each character is considered an element within the predicate. The returned collection is a List.</p> <pre><code>count(_ == \"a\", \"ab\")</code></pre> <pre><code>count(_ % 2, 1..5)</code></pre> <pre><code>count(_ % 2, 1..=5)</code></pre>"},{"location":"builtins/#zip","title":"zip","text":"<pre><code>zip(collection, ..collections)</code></pre> <p>Takes any number of iterables as an argument and aggregates them together producing a List/Lazy Sequence of List tuples. Each List tuple contains elements of all iterables occurring at the same position, stopping when the shortest iterables is exhausted.</p> <pre><code>zip(0.., \"abc\", [1.5, 2.5, 3.5])</code></pre> <pre><code>zip(0.., \"abcdef\", [1.5, 2.5, 3.5])</code></pre> <p>If any of the iterables have a finite size then a List is returned, else a Lazy Sequence is produced.</p> <pre><code>zip(0.., 1..) |&gt; take(3)</code></pre>"},{"location":"builtins/#sum","title":"sum","text":"<pre><code>sum(collection)</code></pre> <p>Sum all the Integer elements within a collection.</p> ListSetDictionaryExclusive RangeInclusive Range <pre><code>sum([1, 2])</code></pre> <pre><code>sum({1, 2})</code></pre> <pre><code>sum(#{1: 2, 3: 4})</code></pre> <pre><code>sum(1..5)</code></pre> <pre><code>sum(1..=5)</code></pre>"},{"location":"builtins/#max","title":"max","text":"<pre><code>max(..values)</code></pre> <p>Find the largest (maximum) element within a collection. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>max(1, 2) == max([1, 2])</code></pre> ListSetDictionaryExclusive RangeInclusive Range <pre><code>max([1, 2])</code></pre> <pre><code>max({1, 2})</code></pre> <pre><code>max(#{1: 2, 3: 4})</code></pre> <pre><code>max(1..5)</code></pre> <pre><code>max(1..=5)</code></pre>"},{"location":"builtins/#min","title":"min","text":"<pre><code>min(..values)</code></pre> <p>Find the smallest (minimum) element within a collection. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>min(1, 2) == min([1, 2])</code></pre> ListSetDictionaryExclusive RangeInclusive Range <pre><code>min([1, 2])</code></pre> <pre><code>min({1, 2})</code></pre> <pre><code>min(#{1: 2, 3: 4})</code></pre> <pre><code>min(1..5)</code></pre> <pre><code>min(1..=5)</code></pre>"},{"location":"builtins/#skip","title":"skip","text":"<pre><code>skip(total, collection)</code></pre> <p>Skip a number of elements within a collection. If the collection is a Lazy Sequence the skip is applied when the collection is lazily resolved.</p> ListSetExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>skip(1, [1, 2, 3])</code></pre> <pre><code>skip(1, {1, 2, 3})</code></pre> <pre><code>skip(2, 1..5)</code></pre> <pre><code>skip(2, 1..=5)</code></pre> <pre><code>skip(2, 1..) |&gt; take(3)</code></pre> <pre><code>skip(2, iterate(_ + 1, 1)) |&gt; take(3)</code></pre>"},{"location":"builtins/#take","title":"take","text":"<pre><code>take(total, collection)</code></pre> <p>Take a number of elements from a collection. If the collection is a Lazy Sequence then the collection is resolved with any outstanding operations (<code>map</code>, <code>skip</code> etc.) being applied.</p> ListSetExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>take(2, [1, 2, 3])</code></pre> <pre><code>take(2, {1, 2, 3})</code></pre> <pre><code>take(2, 1..5)</code></pre> <pre><code>take(2, 1..=5)</code></pre> <pre><code>take(2, 1..)</code></pre> <pre><code>take(2, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#sort","title":"sort","text":"<pre><code>sort(comparator, collection)</code></pre> <p>Sort the collection based on a supplied pure <code>comparator</code> function. The comparator function accepts two values (a, b) from the collection and can either return:</p> <p>The Boolean value, with <code>false</code> signifying a &lt; b and <code>true</code> signifying a &gt; b.</p> <pre><code>sort(&gt;, [3, 2, 1])</code></pre> <p>The Integer value, with a negative value signifying a &lt; b, zero signifying a == b, and a positive value signifying a &gt; b.</p> <pre><code>sort(-, [3, 2, 1])</code></pre>"},{"location":"builtins/#reverse","title":"reverse","text":"<pre><code>reverse(collection)</code></pre> <p>Reverse the order of a given List collection.</p> ListStringExclusive RangeInclusive Range <pre><code>reverse([1, 2, 3])</code></pre> <pre><code>reverse(\"abc\")</code></pre> <pre><code>reverse(1..5)</code></pre> <pre><code>reverse(1..=5)</code></pre>"},{"location":"builtins/#repeat","title":"repeat","text":"<pre><code>repeat(value)</code></pre> <p>Generate a Lazy Sequence which repeats the provided value indefinitely.</p> <pre><code>repeat(1) |&gt; take(3)</code></pre>"},{"location":"builtins/#cycle","title":"cycle","text":"<pre><code>cycle(list)</code></pre> <p>Generate a Lazy Sequence which cycles through each element in a List indefinitely, looping back to the start once exhausted.</p> ListString <pre><code>cycle([1, 2, 3]) |&gt; take(4)</code></pre> <p>Each character is considered an element within the Lazy Sequence.</p> <pre><code>cycle(\"abc\") |&gt; take(4)</code></pre>"},{"location":"builtins/#iterate","title":"iterate","text":"<pre><code>iterate(generator, initial)</code></pre> <p>Generate a Lazy Sequence which supplies a provided pure <code>generator</code> function with the previous result (starting with an initial value) to produce the next value in the sequence.</p> <pre><code>iterate(|[a, b]| [b, a + b], [0, 1])\n  |&gt; skip(9)\n  |&gt; take(1)</code></pre> <pre><code>iterate(_ * 2, 1) |&gt; take(5)</code></pre>"},{"location":"builtins/#keys","title":"keys","text":"<pre><code>keys(dictionary)</code></pre> <p>Return the keys in a given Dictionary as a List.</p> <pre><code>keys(#{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#values","title":"values","text":"<pre><code>values(dictionary)</code></pre> <p>Return the values in a given Dictionary as a List.</p> <pre><code>values(#{1: 2, 3: 4})</code></pre>"},{"location":"builtins/#first","title":"first","text":"<pre><code>first(collection)</code></pre> <p>Return the first element within the collection (aka head). If the collection is empty then <code>nil</code> is returned.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>first([1, 2])</code></pre> <pre><code>first({1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>first(\"ab\")</code></pre> <pre><code>first(1..5)</code></pre> <pre><code>first(1..=5)</code></pre> <pre><code>first(1..)</code></pre> <pre><code>first(iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#second","title":"second","text":"<pre><code>second(collection)</code></pre> <p>Return the second element within the collection. If the collection does not contain a second element then <code>nil</code> is returned.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>second([1, 2])</code></pre> <pre><code>second({1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>second(\"ab\")</code></pre> <pre><code>second(1..5)</code></pre> <pre><code>second(1..=5)</code></pre> <pre><code>second(1..)</code></pre> <pre><code>second(iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#rest","title":"rest","text":"<pre><code>rest(collection)</code></pre> <p>Return the collection with the first element omitted (aka tail). If the collection does not have more than one element then an empty List is returned.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>rest([1, 2])</code></pre> <pre><code>rest({1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>rest(\"ab\")</code></pre> <pre><code>rest(1..5)</code></pre> <pre><code>rest(1..=5)</code></pre> <pre><code>rest(1..)</code></pre> <pre><code>rest(iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#union","title":"union","text":"<pre><code>union(..values)</code></pre> <p>Return the elements (as a Set) which are found in any of the provided collections. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>union([{1, 2}, [2, 3], 1..4, \"abc\"])</code></pre> <pre><code>union({1, 2}, [2, 3], 1..4, \"abc\")</code></pre>"},{"location":"builtins/#intersection","title":"intersection","text":"<pre><code>intersection(..values)</code></pre> <p>Return the elements (as a Set) which are found in all the provided collections. The collections can be supplied as a single argument List (containing multiple collections), or as a multi-arity function call.</p> <pre><code>intersection([{1, 2}, [2, 3], 1..4, \"abc\"])</code></pre> <pre><code>intersection({1, 2}, [2, 3], 1..4, \"abc\")</code></pre>"},{"location":"builtins/#rotate","title":"rotate","text":"<pre><code>rotate(steps, collection)</code></pre> <p>Rotate a given List a number of steps. If the step number is positive the rotation proceed forward, with the last item moving to the start of the List. If the step number is negative the rotation will go backwards, with the first item moving to the end of the List.</p> <pre><code>rotate(5, [1, 2, 3])</code></pre> <pre><code>rotate(-5, [1, 2, 3])</code></pre>"},{"location":"builtins/#chunk","title":"chunk","text":"<pre><code>chunk(size, collection)</code></pre> <p>Split a List into chunks based on a given size. If the List size is not divisible by the chunk size then the last chunk will contain fewer than the desired elements.</p> <pre><code>chunk(2, [1, 2, 3])</code></pre> <pre><code>chunk(2, [1, 2, 3, 4])</code></pre>"},{"location":"builtins/#combinations","title":"combinations","text":"<pre><code>combinations(size, collection)</code></pre> <p>Generate a Lazy Sequence which produces all the possible combinations of a desired number of elements from within a List.</p> <pre><code>combinations(1, [1, 2, 3, 4, 5]) |&gt; list</code></pre> <pre><code>combinations(2, [1, 2, 3, 4, 5]) |&gt; list</code></pre>"},{"location":"builtins/#includes","title":"includes?","text":"<pre><code>includes?(collection, value)</code></pre> <p>Predicate to assert if a value is present within a given collection, based on equality rules.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>includes?([1, 2], 1)</code></pre> <pre><code>includes?({1, 2}, 1)</code></pre> <p>Each character is considered an element.</p> <pre><code>includes?(\"ab\", \"a\")</code></pre> <pre><code>includes?(1..5, 1)</code></pre> <pre><code>includes?(1..=5, 1)</code></pre> <pre><code>includes?(1.., 5)</code></pre> <pre><code>includes?(iterate(_ + 1, 1), 5)</code></pre>"},{"location":"builtins/#excludes","title":"excludes?","text":"<pre><code>excludes?(collection, value)</code></pre> <p>Predicate to assert if a value is not present within a given collection, based on equality rules.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>excludes?([1, 2], 3)</code></pre> <pre><code>excludes?({1, 2}, 3)</code></pre> <p>Each character is considered an element.</p> <pre><code>excludes?(\"ab\", \"c\")</code></pre> <pre><code>excludes?(1..5, 6)</code></pre> <pre><code>excludes?(1..=5, 6)</code></pre> <pre><code>excludes?(1.., 0)</code></pre> <pre><code>excludes?(iterate(_ + 1, 1), 0)</code></pre>"},{"location":"builtins/#any","title":"any?","text":"<pre><code>any?(predicate, collection)</code></pre> <p>Predicate to assert if any value within the collection holds truthy based on the supplied pure <code>predicate</code> function.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>any?(_ == 1, [1, 2])</code></pre> <pre><code>any?(_ == 1, {1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>any?(_ == \"a\", \"ab\")</code></pre> <pre><code>any?(_ == 1, 1..5)</code></pre> <pre><code>any?(_ == 1, 1..=5)</code></pre> <pre><code>any?(_ == 1, 1..)</code></pre> <pre><code>any?(_ == 1, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#all","title":"all?","text":"<pre><code>all?(predicate, collection)</code></pre> <p>Predicate to assert if all values within the collection hold truthy based on the supplied pure <code>predicate</code> function.</p> ListSetStringExclusive RangeInclusive RangeUnbounded RangeLazy Sequence <pre><code>all?(_ &gt; 0, [1, 2])</code></pre> <pre><code>all?(_ &gt; 0, {1, 2})</code></pre> <p>Each character is considered an element.</p> <pre><code>all?(_ != \"c\", \"ab\")</code></pre> <pre><code>all?(_ &gt; 0, 1..5)</code></pre> <pre><code>all?(_ &gt; 0, 1..=5)</code></pre> <pre><code>all?(_ &gt; 0, 1..)</code></pre> <pre><code>all?(_ &gt; 0, iterate(_ + 1, 1))</code></pre>"},{"location":"builtins/#math","title":"Math","text":""},{"location":"builtins/#abs","title":"abs","text":"<pre><code>abs(value)</code></pre> <p>Return the absolute value of a number.</p>"},{"location":"builtins/#vec_add","title":"vec_add","text":"<pre><code>vec_add(a, b)</code></pre> <p>Sum two Lists together using Vector addition.</p>"},{"location":"builtins/#signum","title":"signum","text":"<pre><code>signum(value)</code></pre> <p>Return the sign (<code>-1, 0, 1</code>) for the given value.</p>"},{"location":"builtins/#bitwise","title":"Bitwise","text":""},{"location":"builtins/#bit_and","title":"bit_and","text":"<pre><code>bit_and(a, b)</code></pre> <p>Return an Integer whose binary representation has a 1 in each bit position for which the corresponding bits of both operands are 1.</p>"},{"location":"builtins/#bit_or","title":"bit_or","text":"<pre><code>bit_or(a, b)</code></pre> <p>Return an Integer whose binary representation has a 1 in each bit position for which the corresponding bits of either or both operands are 1.</p>"},{"location":"builtins/#bit_xor","title":"bit_xor","text":"<pre><code>bit_xor(a, b)</code></pre> <p>Return an Integer whose binary representation has a 1 in each bit position for which the corresponding bits of either but not both operands are 1.</p>"},{"location":"builtins/#bit_shift_left","title":"bit_shift_left","text":"<pre><code>bit_shift_left(a, b)</code></pre> <p>Return an Integer whose binary representation is the first operand shifted by the specified number of bits to the left.</p>"},{"location":"builtins/#bit_shift_right","title":"bit_shift_right","text":"<pre><code>bit_shift_right(a, b)</code></pre> <p>Return an Integer whose binary representation is the first operand shifted by the specified number of bits to the right.</p>"},{"location":"builtins/#string","title":"String","text":""},{"location":"builtins/#int","title":"int","text":"<pre><code>int(value)</code></pre> <p>Attempt to parse the provided value into an Integer represenation. Upon failure <code>nil</code> is returned.</p>"},{"location":"builtins/#ints","title":"ints","text":"<pre><code>ints(value)</code></pre> <p>Return all parseable Integer values (as per <code>int</code>) from a String value as a List. If no Integers are found and empty List is returned.</p>"},{"location":"builtins/#lines","title":"lines","text":"<pre><code>lines(value)</code></pre> <p>Split a given String into a List of Strings, seperated on new lines <code>\\n</code>.</p>"},{"location":"builtins/#split","title":"split","text":"<pre><code>split(seperator, value)</code></pre> <p>Split a given String into a List of Strings, seperated based on the provided value.</p>"},{"location":"builtins/#regex_match","title":"regex_match","text":"<pre><code>regex_match(pattern, value)</code></pre> <p>Match and capture values from a subject String based on a provided Regular Expression. Captured values are returned as a List of Strings. If no match/capture can be found an empty List is returned.</p>"},{"location":"builtins/#regex_match_all","title":"regex_match_all","text":"<pre><code>regex_match_all(pattern, value)</code></pre> <p>Match and capture all values from a subject String based on a provided Regular Expression. Captured values are returned as a List of Strings. If no match/capture can be found an empty List is returned.</p>"},{"location":"builtins/#miscellaneous","title":"Miscellaneous","text":""},{"location":"builtins/#range","title":"range","text":"<pre><code>range(from, to, step)</code></pre> <p>Generate an Inclusive Range using a custom desired step value (not the default +1, -1).</p>"},{"location":"builtins/#id","title":"id","text":"<pre><code>id(value)</code></pre> <p>Return the value passed in as an argument.</p>"},{"location":"builtins/#memoize","title":"memoize","text":"<pre><code>memoize(function)</code></pre> <p>Return a function which wraps a given pure function memoizing invocation calls for performance. This is a trade-off between space and time complexity.</p>"},{"location":"builtins/#evaluate","title":"evaluate","text":"<pre><code>evaluate(source)</code></pre>"},{"location":"builtins/#type","title":"type","text":"<pre><code>type(value)</code></pre>"},{"location":"cli/","title":"CLI","text":""},{"location":"examples/","title":"Examples","text":"<p>TODO</p>"},{"location":"lambda/","title":"Lambda","text":""},{"location":"language/","title":"Language","text":"<ul> <li>Everything is an expression.</li> <li>Everything is an function (mostly).</li> <li>Semicolons are optional.</li> <li>Block expressions implicitly return the last statement as their result, unless an explicit <code>return</code> is used.</li> </ul> <p>There is a write-up detailing the design decisions that went into creating the langauge.</p>"},{"location":"language/#types","title":"Types","text":""},{"location":"language/#integer","title":"Integer","text":"<p>Represents Integer values, stored as a 64-bit signed number.</p> <pre><code>let int = 1;\nlet int_with_underscores = 1_000_000;</code></pre>"},{"location":"language/#decimal","title":"Decimal","text":"<p>Represents Decimal values, stored as a 64-bit floating point number (the binary64 type defined in IEEE 754-2008).</p> <pre><code>let dec = 1.5;\nlet dec_with_underscores = 1_000_000.50;</code></pre>"},{"location":"language/#string","title":"String","text":"<p>Represents UTF-8 encoded character sequences, with the ability to escape newlines <code>\\n</code>, tabs <code>\\t</code> and quotes <code>\\\"</code>.</p> <pre><code>let str = \"Hello, world!\";\nlet escaped_str = \"\\\"Hello, world!\\\"\\n\";\nlet str_with_unicode = \"\u2764\ud83c\udf55\";</code></pre>"},{"location":"language/#range","title":"Range","text":""},{"location":"language/#exclusive-range","title":"Exclusive Range","text":"<p>Lazily evaluates the Integer range from a given start value until (but not including) the end value. If the start value is greater than the end value then a -1 step is applied each iteration.</p> <pre><code>let asc_exc_range = 1..5;\nlet desc_exc_range = 2..-2;</code></pre> <pre><code>let until = 5;\nlet exc_range_using_expr = (0 + 1)..until;</code></pre>"},{"location":"language/#inclusive-range","title":"Inclusive Range","text":"<p>Lazily evaluates the Integer range from a given start value until (and including) the end value. If the start value is greater than the end value then a -1 step is applied each iteration.</p> <pre><code>let asc_inc_range = 1..=5;\nlet desc_inc_range = 2..=-2;</code></pre> <pre><code>let to = 5;\nlet inc_range_using_expr = (0 + 1)..=to;</code></pre>"},{"location":"language/#unbounded-range","title":"Unbounded Range","text":"<p>Lazily evaluates an infinite Integer range from a given start value, using +1 step each iteration.</p> <pre><code>let inf_range = 1..;\nlet neg_inf_range = -5..;</code></pre>"},{"location":"language/#collection","title":"Collection","text":"<p>Collections are persistent data-structures, yielding new values upon mutation.</p>"},{"location":"language/#list","title":"List","text":"<p>Represents a sequence of heterogeneous elements in insertion order.</p> <pre><code>let homogeneous_list = [1, 2, 3];\nlet heterogeneous_list = [\"4\", 5.0];</code></pre> <pre><code>let list = [1, 2, 3];\nlist |&gt; push(4); // [1, 2, 3, 4]\nlist; // [1, 2, 3]</code></pre>"},{"location":"language/#set","title":"Set","text":"<p>Represents an unordered collection of unique heterogeneous elements.</p> <pre><code>let homogeneous_set = {1, 2, 2, 3}; // {1, 2, 3}\nlet heterogeneous_set = {\"4\", 5.0, \"4\"}; // {\"4\", 5.0}</code></pre> <pre><code>let set = {1, 2, 3};\nset |&gt; push(4); // {1, 2, 3, 4};\nset; // {1, 2, 3}</code></pre> <p>Most types can be stored within a Set, except for Lazy Sequences and Functions.</p> <pre><code>let set = {1, || 1}; // Error</code></pre>"},{"location":"language/#dictionary","title":"Dictionary","text":"<p>Represents an unordered association between arbitrary keys and values.</p> <pre><code>let homogeneous_dict = #{\"a\": 1, \"b\": 2};\nlet heterogeneous_dict = #{[1]: 1.5, 2: true, homogeneous_dict};</code></pre> <pre><code>let dictionary = #{\"a\": 1};\ndictionary |&gt; assoc(\"a\", 2); // #{\"a\": 2}\ndictionary; // #{\"a\": 1}</code></pre> <p>Most types can be used as Dictionary keys, except for Lazy Sequences and Functions.</p> <pre><code>let attempted_key = || 1;\nlet dictionary = #{attempted_key: \"one\"}; // Error</code></pre>"},{"location":"language/#lazy-sequence","title":"Lazy Sequence","text":"<p>The language supports the concept of Lazy Sequences, which among other benefits, unlock the ability to produce infinite sequences. Both bounded (inclusive, exclusive) and unbounded (infinite) Ranges are examples of an Lazy Sequence. Functions (such as <code>filter</code> and <code>map</code>) are applied only when required, in the example below when we invoke <code>take</code>.</p> <pre><code>1.. |&gt; filter(|n| n % 2 == 0) |&gt; take(5);</code></pre> <p>The sequence is an immutable definition of desired computation and can be shared.</p> <pre><code>let lazy_seq = zip(1.., 2..) |&gt; map(|[x, y]| x * y);\n[\n  lazy_seq |&gt; skip(5) |&gt; first,\n  lazy_seq |&gt; first\n];</code></pre> <p>Their are several other means of generating a Lazy Sequence:</p> <p>Iterate takes a pure function and applies the previous result (starting with an initial value) upon each iteration.</p> <pre><code>iterate(|[a, b]| [b, a + b], [0, 1]) |&gt; find(|[a]| a &gt; 10);</code></pre> <p>Cycle iterates through a List indefinitely, looping back to the start once exhausted.</p> <pre><code>cycle([1, 2, 3]) |&gt; skip(1) |&gt; take(3);</code></pre> <p>Repeat iterates over the same value indefinitely.</p> <pre><code>repeat(\"a\") |&gt; take(3);</code></pre>"},{"location":"language/#truthy-semantics","title":"Truthy Semantics","text":"<p>Values can be evaluated to a Boolean within predicate expressions using the truthy semantic rules below:</p> Type True Integer Not 0 Decimal Not 0.0 String Not empty List Not empty Set Not empty Dictionary Not empty LazySequence Always Function Always"},{"location":"language/#variables","title":"Variables","text":"<p>Variables are declared using let-binding syntax, with names conforming to <code>[a-Z][a-Z0-9_?]+</code>. Bindings are immutable by-default, and can not be reassigned after declaration.</p> <pre><code>let x = 1;\nx = 2; // Variable 'x' is not mutable</code></pre> <p>Variables can be made mutable using the <code>mut</code> keyword, allowing for the binding to be reassigned after declaration.</p> <pre><code>let mut x = 1;\nx = 2;</code></pre>"},{"location":"language/#destructing","title":"Destructing","text":"<p>List collection values can be destructed into desired let-bindings. The <code>_</code> placeholder symbol is used to denote an ignored positional binding. The <code>..</code> rest symbol is used to collect all the remaining elements into a single List let-binding.</p> <pre><code>let [x, y, _, ..z] = [1, 2, 3, 4, 5];\n[x, y, z];</code></pre> <p>Similar to previous let-bindings, these are immutable by-default. Destructed bindings can be made mutable using the <code>mut</code> keyword.</p> <pre><code>let mut [x, y] = [1, 2];\nx = 2;</code></pre>"},{"location":"language/#operators","title":"Operators","text":"<p>Expected arthritic operations on Integer and Decimal values are available, along with intuitive behaviour on other types.</p> <pre><code>1 + 1; // 2\n1 + 2.5; // 3\n1.5 + 3.25; // 4.75\n1.5 + 1; // 2.5\n\"a\" + \"b\"; // \"ab\"\n[1] + [2, 3]; // [1, 2, 3]\n{1} + {1, 2}; // {1, 2}\n#{1: \"one\"} + #{2: \"two\"}; // #{1: \"one\", 2: \"two}</code></pre> <pre><code>2 - 1; // 1\n2 - 1.5; // 1\n1.5 - 1.25; // 0.25\n1.5 - 1; // 0.50\n{1, 2} - {1}; // {2}</code></pre> <pre><code>2 * 2; // 4\n2.2 * 2; // 4.4\n\"a\" * 3; // \"aaa\"\n[\"a\"] * 2; // [\"a\", \"a\"]</code></pre> <pre><code>5 / 2; // 2\n5 / 2.25; // 2\n5.0 / 2; // 2.5\n5.0 / 2.25; // 2.22</code></pre> <p>Logical OR and AND operations are supported for all values. Non-Boolean values are evaluated based on truthy value semantics.</p> <pre><code>true || false;\n1 || 0;</code></pre> <pre><code>true &amp;&amp; true;\n[1] &amp;&amp; {1};</code></pre> <p>Intuitive equality operations are support for all values.</p> <pre><code>1 == 1;\n1.5 == 1.5;\n\"a\" == \"a\";\ntrue == true;\n[1, 2, 3] == [1, 2, 3];\n{1, 2, 3} == {1, 2, 3};\n#{\"a\": 1} == #{\"a\": 1};</code></pre> <pre><code>1 != 2;\n1.5 != 2.0;\n\"a\" != \"b\";\ntrue != false;\n[1, 2, 3] != [1, 2, 3, 4]\n{1, 2, 3} != {1, 2, 3, 4};\n#{\"a\": 1} != #{\"b\": 2};</code></pre>"},{"location":"language/#indexing","title":"Indexing","text":""},{"location":"language/#list_1","title":"List","text":"<p>List indexing is zero-based, with the ability to index from the start (positive index) and end (negative index) of a sequence. If an element is not found at the given index <code>nil</code> is returned.</p> <pre><code>let list = [1, 2, 3, 4];\n\nlist[0]; // 1\nlist[-1]; // 4\nlist[4]; // nil\nlist[-5]; // nil</code></pre> <p>List slices can be achieved by-way of inclusive/exclusive range indexing.</p> <pre><code>let list = [1, 2, 3, 4];\n\nlist[1..2]; // [2]\nlist[1..=2]; // [2, 3]\nlist[1..=-1]; // [2, 1, 4]</code></pre>"},{"location":"language/#dictionary_1","title":"Dictionary","text":"<p>Dictionary values can be found via their associated key. If a Dictionary key is not present within the collection <code>nil</code> is returned.</p> <pre><code>let dictionary = #{\"a\": 1, \"b\": 2};\n\ndictionary[\"a\"]; // 1\ndictionary[\"c\"]; // nil</code></pre>"},{"location":"language/#string_1","title":"String","text":"<p>String indexing follows much of the same semantics as List indexing, with elements instead being UTF-8 characters. The returned element is the single UTF-8 character as represented as a String.</p> <pre><code>let str = \"hello\";\n\nstr[0]; // \"h\"\nstr[-1]; // \"o\"\nstr[5]; // nil\nstr[-6]; // nil</code></pre> <p>String slices can be achieved by-way of inclusive/exclusive range indexing.</p> <pre><code>let str = \"hello\";\n\nstr[1..2]; // \"e\"\nstr[1..=2]; // \"el\"\nstr[1..=-1]; // \"eho\"</code></pre>"},{"location":"language/#control-structures","title":"Control Structures","text":""},{"location":"language/#if","title":"If","text":"<p>This expression provides a means of performing conditional logic. The supplied predicate expressions is evaluated using truthy value semantics. The expression always returns a value; with <code>nil</code> being returned in the case of the alternative branch not being specified and condition not passing. Following block expression semantics found elsewhere in the language, unless explicitly stated (via the <code>return</code> keyword) the last statement is implicitly returned as the result.</p> <p>Expression without an alternative <code>else</code> branch.</p> <pre><code>if 5 &lt; 10 { 1 } // 1\nif 10 &lt; 5 { 1 } // nil</code></pre> <p>Expression with both a consequence and alternative <code>else</code> branch.</p> <pre><code>if 10 &lt; 5 { 1 } else { 2 }</code></pre> <p>Let-bindings can be declared within the predicate expressions. If the binding is truthy then the variables is bound and available with the consequence branch.</p> <pre><code>if let x = 10 { x } else { 20 }</code></pre>"},{"location":"language/#return","title":"Return","text":"<p>If you wish to return early from a block expression this can be achieved using the <code>return</code> keyword.</p> <pre><code>let ten = |x| {\n  if x &gt; 10 {\n    return \"&gt; 10\"\n  }\n  return \"&lt; 10\"\n}\nten(5);</code></pre>"},{"location":"language/#break","title":"Break","text":"<p>If you wish to break early from a builtin looping construct (i.e <code>fold</code>, <code>reduce</code>, <code>each</code>) this can be achieved with the <code>break</code> keyword. In the example below the reduction will be terminated prematurely and the break value will be returned.</p> <pre><code>0.. |&gt; reduce |acc, value| {\n  if value == 10 {\n    break acc\n  } else {\n    acc + value\n  }\n};</code></pre>"},{"location":"language/#match","title":"Match","text":"<p>The match expression allows you to perform pattern matching on a given subject. If no match is found <code>nil</code> is returned as the expression result.</p> <p>Primitive type values can be matched based on equality rules.</p> <pre><code>let fibonacci = |n| match n {\n  0 { 0 }\n  1 { 1 }\n  n { fibonacci(n - 1) + fibonacci(n - 2) }\n};\nfibonacci(10);</code></pre> <p>List patterns can be matched upon and destructed into let-bindings.</p> <pre><code>let map = |fn, list| match list {\n  [] { [] }\n  [head] { [fn(head)] }\n  [head, ..tail] { [fn(head), ..map(fn, tail)] }\n};\nmap(_ + 1, [1, 2, 3]);</code></pre> <p>Values within Integer ranges can be matched upon.</p> <pre><code>let number = |n| match n {\n  0..5 { \"&lt; 5\" },\n  5..=6 { \"5 or 6\" }\n  7.. { \"&gt;= 7\" }\n};\nnumber(5);</code></pre> <p>An optional predicate expression guard can be defined based on a matched pattern.</p> <pre><code>let filter = |fn, list| match list {\n  [] { [] }\n  [head] if fn(head) { [head] }\n  [head, ..tail] if fn(head) { [head, ..filter(fn, tail)] }\n  [_, ..tail] { filter(fn, tail) }\n};\nfilter(_ != 2, [1, 2, 3]);</code></pre>"},{"location":"language/#functions","title":"Functions","text":"<p>Defining functions (closures) within the language is intentionally very easy and syntactically cheap to do.</p> <p>The most basic means of creating a function is to define one using the pipe syntax.</p> <pre><code>let inc = |x| { x + 1 };\ninc(1);</code></pre> <p>In the event of a single-line block expression, the brackets can be omitted.</p> <pre><code>let inc = |x| x + 1;\ninc(1);</code></pre> <p>Additionally you can partially apply an existing function, which in-turn will create a new function with the remaining parameter arity.</p> <pre><code>let inc = +(1);\ninc(1);</code></pre> <p>This also highlights use of operators being passed around as first-class functions.</p> <p>The placeholder <code>_</code> symbol can also be used to positional omit parameters in which you wish to leave open for the newly created function.</p> <pre><code>let minus = -;\nlet dec = minus(_, 1);\ndec(2);</code></pre> <p>Alternatively binary functions (functions which take two arguments) can be more succinctly written using the following placeholder syntax, borrowed from Scala.</p> <pre><code>let inc = 1 + _;\nlet dec = _ - 1;\ninc(1) == dec(3);</code></pre> <p>All functions which are declared are Closures, and have access to their outer scope variables.</p> <pre><code>let fibonacci_seq = || {\n  let mut [a, b] = [0, 1];\n  || {\n    let aa = a;\n    a = b; b = aa + b;\n    a;\n  };\n}();\nfibonacci_seq();\nfibonacci_seq();</code></pre> <p>Function arguments can be spread from a List, as well as parameters be collected rest into a List.</p> <pre><code>let max = |..xs| xs |&gt; sort(&lt;) |&gt; first;\nmax(..[1, 2, 3]);</code></pre>"},{"location":"language/#recursion","title":"Recursion","text":"<p>Recursive function invocation is supported.</p> <pre><code>let factorial = |n| if n == 0 { 1 } else { n * factorial(n - 1) };\nfactorial(10);</code></pre> <p>Along with Tail-call optimization. To avoid exhausting the call stack, the above <code>factorial</code> function can be rewritten in a tail-recursive form. In this case the runtime will reuse the function call stack frame upon each iteration.</p> <pre><code>let factorial = |n| {\n  let recur = |acc, n| {\n    if n == 0 { acc } else { recur(acc * n, n - 1) }\n  };\n  recur(1, n);\n};\nfactorial(10);</code></pre>"},{"location":"language/#composition","title":"Composition","text":"<p>Functions can be composed together using the <code>&gt;&gt;</code> syntax.</p> <pre><code>let inc_dbl = _ + 1 &gt;&gt; |x| x * x;\ninc_dbl(15);</code></pre> <pre><code>let parse = lines &gt;&gt; map(split(\",\") &gt;&gt; map(int));\nparse(\"1,2\\n3,4\\n5,6\");</code></pre> <p>This is syntactic sugar on top of the following expression.</p> <pre><code>let parse = |x| {\n  map(|line| map(int, split(\",\", line)), lines(x));\n};\nparse(\"1,2\\n3,4\\n5,6\");</code></pre>"},{"location":"language/#threading","title":"Threading","text":"<p>The language leans heavily on functions, and so as to improve readability invocation can be threaded using the <code>|&gt;</code> syntax.</p> <pre><code>1..5 |&gt; map(_ + 1) |&gt; reduce(+);</code></pre> <p>This is syntactic sugar on top of the following expression.</p> <pre><code>reduce(+, map(_ + 1, 1..5));</code></pre>"},{"location":"language/#trailing-lambda","title":"Trailing Lambda","text":"<p>If the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses. Inspired by Kotlin, this improves readability and enables rich DSLs to be built on-top of language constructs.</p> <pre><code>let mut acc = 1;\n[1, 2, 3] |&gt; each |x| {\n  acc = acc + x * x;\n}\nacc;</code></pre> <pre><code>[1, 2, 3] |&gt; fold(1) |acc, x| {\n  acc + x * x;\n};</code></pre> <p>This is syntactic sugar on top of the following expressions.</p> <pre><code>let mut acc = 1;\neach(|x| { acc = acc + x * x; }, [1, 2, 3]);\nacc;</code></pre> <pre><code>fold(1, |acc, x| acc + x * x, [1, 2, 3]);</code></pre>"},{"location":"language/#infix-invocation","title":"Infix invocation","text":"<p>Functions which accept two arguments (binary) can be called within the infix position like so:</p> <pre><code>[1, 2, 3] `includes?` 3;</code></pre> <p>This is syntactic sugar on top of the following expression.</p> <pre><code>includes?([1, 2, 3], 3);</code></pre>"},{"location":"language/#memoization","title":"Memoization","text":"<p>Referential transparent function calls can be memoized using the built-in higher-order function.</p> <pre><code>let fibonacci = memoize |n| {\n  if (n &gt; 1) {\n    fibonacci(n - 1) + fibonacci(n - 2)\n  } else {\n    n\n  }\n}\nfibonacci(50);</code></pre> <p>This highlights the use of the trailing lambda syntax to produce a rich DSL which looks like a language construct.</p>"},{"location":"language/#builtins","title":"Builtins","text":"<p>There is a suite of builtin functions which help solve many different class of problem.</p>"},{"location":"php-ext/","title":"PHP Extension","text":""},{"location":"runner/","title":"AoC Runner","text":"<p>TODO</p>"},{"location":"wasm/","title":"WebAssembly","text":""}]}