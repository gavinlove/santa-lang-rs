{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Cli - WebAssembly - Lambda</p>"},{"location":"#santa-lang","title":"santa-lang","text":"<p>An functional, C-like programming language for solving Advent of Code puzzles.</p> <p>Influenced by: Rust, Python, Clojure, F#, Scala</p>"},{"location":"#why","title":"Why?","text":"<p>Over the past several years I have been slowly working through the previous Advent of Code calendars. For each calendar I opt to solve the puzzles in a new programming language, to familiarise myself with other ways of understanding and working. However, there comes a time in each calendar that I grow to dislike some aspect of the language. So I had an idea... why not give this whole programming langauge design a go. That way if I grow to dislike this language, I only have myself to blame!</p> <p>Welcome santa-lang, my tree-walking interpreted programming language designed to help tackle Advent of Code puzzles.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#reimplementing-map-filter-fold-and-reduce","title":"Reimplementing <code>map</code>, <code>filter</code>, <code>fold</code> and <code>reduce</code>","text":"<p>These fundamental functions come part of the standard library, however, they can be re-implemented within the language itself like so:</p> <pre><code>let map = |fn, list| match list {\n  [] { [] }\n  [head] { [fn(head)] }\n  [head, ..tail] { [fn(head), ..map(fn, tail)] }\n};\n\nmap(_ + 1, [1, 2, 3]);\n</code></pre> <pre><code>let filter = |fn, list| match list {\n  [] { [] }\n  [head] if fn(head) { [head] }\n  [head, ..tail] if fn(head) { [head, ..filter(fn, tail)] }\n  [_, ..tail] { filter(fn, tail) }\n};\n\nfilter(_ != 2, [1, 2, 3])\n</code></pre> <pre><code>let fold = |initial, fn, list| {\n  let recur = |acc, list| match list {\n    [] { acc }\n    [head] { fn(acc, head) }\n    [head, ..tail] { recur(fn(acc, head), tail) }\n  };\n  recur(initial, list);\n};\n\nfold(0, +, [1, 2, 3]);\n</code></pre> <pre><code>let reduce = |fn, list| {\n  let recur = |acc, list| match list {\n    [] { acc }\n    [head] { fn(acc, head) }\n    [head, ..tail] { recur(fn(acc, head), tail) }\n  };\n  recur(list[0], list[1..]);\n};\n\nreduce(+, [1, 2, 3]);\n</code></pre>"},{"location":"language/","title":"Language","text":""},{"location":"language/#features","title":"Features","text":""},{"location":"language/#types","title":"Types","text":"<pre><code>let int = 1;\nlet dec = 1.5;\nlet exc_range = 1..5;\nlet inc_range = 1..=5;\nlet inf_range = 1..;\nlet string = \"Hello, world!\\n\";\nlet list = [1, 2, 3];\nlet hash_map = #{\"a\": 1, 2.5: \"b\", [1, 2, 3]: true, range};\nlet set = {1, 2, 3};\n</code></pre>"},{"location":"language/#persistent-immutable-data-structures","title":"Persistent (Immutable) data-structures","text":"<p>Lists, Maps and Sets are all persistent data-structures, yielding new values upon mutation.</p> <pre><code>let list = [1, 2, 3];\nlist |&gt; push(4); // [1, 2, 3, 4]\nlist; // [1, 2, 3]\n</code></pre> <pre><code>let hash_map = #{\"a\": 1};\nhash_map |&gt; assoc(\"a\", 2); // #{\"a\": 2}\nhash_map; // #{\"a\": 1}\n</code></pre> <pre><code>let set = {1, 2, 3};\nset |&gt; push(4); // {1, 2, 3, 4};\nset; // {1, 2, 3}\n</code></pre> <p>Data-structures follow the same value semantics as Integers, Decimals and Strings.</p> <pre><code>[1, 2, 3] == [1, 2, 3]; // true\n[1, 2, 3] == [1, 2, 3, 4]; // false\n</code></pre> <pre><code>#{\"a\": 1} == #{\"a\": 1}; // true\n#{\"a\": 1} == #{\"a\": 1, \"b\": 2}; // false\n</code></pre> <pre><code>{1, 2, 3} == {1, 2, 3}; // true\n{1, 2, 3} == {1, 2, 3, 4}; // false\n</code></pre>"},{"location":"language/#list-slicing","title":"List Slicing","text":"<pre><code>let xs = [1, 2, 3, 4];\n\nxs[0]; // 1\nxs[-1]; // 4\nxs[1..2]; // [2]\nxs[1..=2]; // [2, 3]\n</code></pre>"},{"location":"language/#let-bindings","title":"Let bindings","text":"<pre><code>let x = 1;\nx = 2; // Variable x is not mutable\n\nlet mut x = 1;\nx = 2;\n\nlet [x, y, _, ..z] = [1, 2, 3, 4, 5];\n[x, y, z]; // [1, 2, [4, 5]]\nx = 2; // Variable x is not mutable\n\nlet mut [x, y] = [1, 2];\nx = 2;\n</code></pre>"},{"location":"language/#conditionals-with-let-bindings","title":"Conditionals (with let bindings)","text":"<pre><code>if x &lt; 10 { 1 } else { 2 }\nif let x = 10 { x } else { 20 }\n</code></pre>"},{"location":"language/#functions-functions-functions","title":"Functions, functions, functions!","text":"<pre><code>let inc = +(1);\nlet inc = _ + 1;\nlet inc = |x| x + 1;\n\nmap(inc, 1..5); // [2, 3, 4, 5]\nfilter(2 != _, 1..5); // [1, 3, 4]\nreduce(+, 1..=5); // 15\nfold(10, +, 1..=5); // 25\n</code></pre>"},{"location":"language/#function-composition-and-threading","title":"Function composition and threading","text":"<pre><code>let inc_dbl = _ + 1 &gt;&gt; |x| x * x;\ninc_dbl(15); // 256\n\nreduce(*, map(inc_dbl, 1..5));\n// vs\n1..5 |&gt; map(inc_dbl) |&gt; reduce(*);\n</code></pre>"},{"location":"language/#invocation-with-trailing-lambdas","title":"Invocation with trailing lambdas","text":"<p>If the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses.</p> <pre><code>[1, 2, 3] |&gt; each |x| {\n  puts(x);\n}\n// vs\neach(|x| { puts(x) }, [1, 2, 3]);\n\n[1, 2, 3] |&gt; fold(1) |acc, x| {\n  acc + x * x;\n}\n// vs\nfold(1, |acc, x| acc + x * x, [1, 2, 3]);\n</code></pre>"},{"location":"language/#infix-function-calls","title":"Infix function calls","text":"<p>Functions which accept two arguments (binary) can be called within the infix position like so:</p> <pre><code>includes?([1, 2, 3], 3);\n// vs\n[1, 2, 3] `includes?` 3;\n</code></pre>"},{"location":"language/#lazy-sequences","title":"Lazy sequences","text":"<pre><code>1.. |&gt; filter(|n| n % 2 == 0) |&gt; take(5); // [2, 4, 6, 8, 10]\n\nzip(1.., 2..) |&gt; map(|[x, y]| x * y) |&gt; take(5); // [2, 6, 12, 20, 30]\n</code></pre>"},{"location":"language/#recursion","title":"Recursion","text":"<pre><code>let factorial = |n| if n == 0 { 1 } else { n * factorial(n - 1) };\n</code></pre>"},{"location":"language/#tail-call-optimization","title":"Tail-call optimization","text":"<p>To avoid exhausting the call stack, the above <code>factorial</code> function can be rewritten in a tail-recursive form.</p> <pre><code>let factorial = |n| {\n  let recur = |acc, n| if n == 0 { acc } else { recur(acc * n, n - 1) };\n  recur(1, n);\n};\n</code></pre>"},{"location":"language/#closures","title":"Closures","text":"<pre><code>let fibonacci_seq = || {\n  let mut [a, b] = [0, 1];\n  || {\n    let aa = a;\n    a = b; b = aa + b;\n    a;\n  };\n}();\n1..=5 |&gt; each(|n| puts(\"&gt; \" + n + \": \" + fibonacci_seq()));\n// \"&gt; 1: 1\"\n// \"&gt; 2: 1\"\n// \"&gt; 3: 2\"\n// \"&gt; 4: 3\"\n// \"&gt; 5: 5\"\n</code></pre>"},{"location":"language/#pattern-matching","title":"Pattern matching","text":"<pre><code>let fibonacci = |n| match n {\n  0 { 0 }\n  1 { 1 }\n  n { fibonacci(n - 1) + fibonacci(n - 2) }\n};\n</code></pre> <pre><code>let step = |face, [y, x]| match [face, [y, x]] {\n  [\"N\", [7, 3..6]]   { [\"S\", [3 - x, 4]] }\n  [\"S\", [3, _]]      { [\"N\", [y - 1, x]] }\n  [\"E\", [0..3, 1..]] { [\"W\", [1 - y, 4]] }\n  [\"W\", _]           { [\"E\", [y, x - 1]] }\n};\n</code></pre>"},{"location":"language/#spread-and-rest-operators","title":"Spread and rest operators","text":"<pre><code>let a = [2];\nlet b = [1, ..a, 3]; // [1, 2, 3]\n\nlet sum = |..xs| reduce(+, xs);\nsum(1, 2, 3) == sum(..b) // 6\n</code></pre>"},{"location":"language/#memoization","title":"Memoization","text":"<p>Referential transparent function calls can be memoized using the built-in higher-order function.</p> <pre><code>let fibonacci = memoize |n| {\n  if (n &gt; 1) {\n    fibonacci(n - 1) + fibonacci(n - 2)\n  } else {\n    n\n  }\n}\n\nfibonacci(50); // 12586269025\n</code></pre>"},{"location":"language/#detailed-error-handling","title":"Detailed error handling","text":"<p>TODO</p>"},{"location":"runner/","title":"AoC Runner","text":""},{"location":"runtimes/cli/","title":"CLI","text":""},{"location":"runtimes/lambda/","title":"Lambda","text":""},{"location":"runtimes/wasm/","title":"WebAssembly","text":""}]}